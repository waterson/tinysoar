Sunday, February 4, 2001

Spent some time debugging the mysterious crash on Win32. Added the
`/MDd' option and debugged a place where I was allocating a block that
was too small. At least now I can reproduce the crash on Windows!

It looks like the problem has to do with updating the preference's
`next_in_instantiation' pointer when we remove a preference from the
linked list of preferences. It's left dangling, pointing at
garbage. (Search on `XXX safe?' in wmem_remove_preference().)

If I can't figure this out, I might need to make a doubly-linked list
of preferences that are owned by each instantiation so I can yank it
there. Hrm, need to think about this a bit more...

                        *       *       *

Maybe I don't need to remember what preferences are owned by an
instantiation at all. Instead, I could just re-process the RHS using
the instantiation that's about to get nuked.

Okay, I think I see the problem with that idea: the instantiation
doesn't remember any identifiers that get generated for unbound
variables. So we won't know how to remove those. Grr.


Sunday, January 21, 2001

I've got some weird corruption crasher going on, Linux only, after
loading `p1.soar' and elaborating a couple of times. It looks like a
preference is holding a dangling pointer in its
`next_in_instantiation' field.

In the spirit of forward flailing, I cobbled together simple negative
conditions in the RETE net; enough to get `p2.soar' nominally
`working'. (It's one frigging production, so it's not like I have a
clue whether this stuff'll fly.) Need to debug in earnest at some
point.

I should create a `preferences' command so that I can add `found-line'
preference to the state to debug the negative condition foo.


Tuesday, January 16, 2001

Got a crude stab at getting the operator decision logic implemented. I
think I might be running into another RETE bug; can't seem to the the
`reconsider' production to fire in `p1.soar'.

                          *       *       *

Okay, so I think I figured out what was wrong: had an off-by-one in
the rete code and was notifying the rete network with the wrong wme
:-/. Now I keep selected `reconsider*wait* over and over again;
however, I'm a bit worried because I don't get new identifiers. Not
that I *expected* to, but I think that `real' Soar might regenerate
identifiers for each new operator that gets selected. Is that
necessary?


Monday, January 15, 2001

So the problem wasn't with propogating wmes into new rules: I was
incorrectly getting some conditions marked randomly as `acceptable'
tests (because I didn't initialize `acceptable' properly in the
`id_test' reduction). Anyway, got past that, but now it seems I'm
getting some token corruption while adding the wme to working memory.


Sunday, January 14, 2001

Seems like it might be a good thing to do away with `productions' in
the runtime. I don't see a real good reason that we need to remember
them.

It looks like the code that's supposed to propogate existing WMEs into
new rules is broken. Gotta look at that.


Monday, January 8, 2001

Need to finish up the semantic actions for rule right-hand
sides. Should simplify so that reductions can uniformly refer to $0 to
add actions.


Wednesday, January 3, 2001

I made WMEs just refer back to the slot they're in to pick up the `id'
and `attr' fields. Can we do the same with preferences?


Friday, December 29, 2000

Hacked up basic symbol table stuff, but will need to expand later to
cough up identifiers by `gc'-ing through live WMEs to find unused
ids. Left off while debugging preferences.


Thursday, December 28, 2000

Fixed the action struct's depth foo as described below.


Tuesday, December 26, 2000

Kludged my way through getting preference memory started. Need to fix
create_instantiation() to do bonafide `gensym'-ing. Maybe it's time to
make a real symbol table?

Also, I hard-coded the initialization of the action struct's `depth'
and `field' values when the rhs_value is a variable binding. That'll
need to move into the rule compilation. Maybe we can initialize with a
variable symbol, and then resolve when making the p-node?


Monday, December 25, 2000

Debugged a single-condition production. Now I'm bombing in a
production with two positive conditions. Gotta fix that.


Tuesday, December 19, 2000

I've got the basic stuff for alpha nodes, memory nodes, and positive
join nodes hooked up. I'm starting to go through debugging
|rete_add_wme()|, and am bombing out in the right-addition routine
because I'm not getting a binding for the `S1' stuff. Need to debug
that.


Tuesday, December 5, 2000

There's also starting to be a bit of redundant code, so a bit of
refactoring will probably be in order shortly.


Monday, December 4, 2000

The rete propogation stuff is buggy right now. The problem is that:

1) I'm just naively letting stuff meander down the net. This'll cause
instantiation nodes to get tickled more than once. I think I need to
make the tests more restrictive by default; esp. simple_test() should
return zero at the end?

2) (Maybe the same as 1, above) I need to be able to go out and check
working memory for values. When I see a WME in simple_test() that
doesn't have the same attribute as the node I'm looking at, I should
go out to working memory and see if there is any element that'll
satisfy my conditions, and only then propogate the stuff onward...

