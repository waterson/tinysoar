/* -*- Mode: Text; indent-tabs-mode: nil -*- */

Saturday, Feburary 10, 2001

Found a couple bone headed mistakes in my hand-rolled linked list
code. That fixed the problem with `init-soar'. Moved the `id' and
`attr' fields out of the `preferences' struct. Replaced them with a
back-pointer to the slot.

Fixed `wmem_remove_preference()' to take a preference pointer (instead
of the same parameter list that `wmem_add_preference()' takes). I did
this because I realized that it should be legal to have >1 identical
preferences in a slot. For example, two different productions assert
the same preference. When one of the instantiations dies, you want to
be sure you yank the right preference. (So that when the other dies,
it'll find /its/ preference.)

I expanded p2.soar, adding a production to set `^found-line t' on the
top-state. It uncovered several bugs:

1. Conditions that compare integer values are broken. (I'm not even
   sure I ever implemented them.)

2. Negative conditions are broken.

   - The don't match properly; e.g., doing

     % pref -a 3 ^sensor-a 75 +

     will properly create a condition that matches
    `implement*find-line*detect-line'; however, creating the
    `^fount-line t' attribute won't retract `propose*find-line'.

   - When we do `init-soar', we're

3. `init-soar' is still crashing. This happens because we weren't
   checking the retraction queue before adding a new instantiation, and
   we ended up with duplicates in the queue.

4. Fixing (3) makes it so that we now don't (appear to) properly
   retract `implement*find-line*move-forward' when a new operator gets
   selected.

On another tangent, it might make sense to have two kinds of
preference structures: one that takes a reference, and one that
doesn't. Save a bit of space, anyway: I bet most preferences are
unary.


Wednesday, Feburary 7, 2001

Went ahead and hacked preferences to be threaded by
instantiation. This probably makes it even more important to move the
`id' and `attr' fields out of the `preference' struct, and just re-use
the values from the slot. (Ideally, we wouldn't even need a
back-pointer to the slot...)

There still are some problems with `init-soar' that I need to track
down. Also, `p2.soar' is acting weird. Need to look at that.


Monday, February 5, 2001

Tinkered with making it so that an instantiation remembers the list of
unbound variables. When the time comes for an instantiation to be
removed, we just ``run the instantiation backwards'', removing all the
preferences that the instantiation created by re-evaluating the RHS
action.

This almost works, except for one problem. The WMEs in the
instantiation's token may very well be gone by the time you're ready
to remove the instantiation!

That doubly-linked list is starting to smell better...


Sunday, February 4, 2001

Spent some time debugging the mysterious crash on Win32. Added the
`/MDd' option and debugged a place where I was allocating a block that
was too small. At least now I can reproduce the crash on Windows!

It looks like the problem has to do with updating the preference's
`next_in_instantiation' pointer when we remove a preference from the
linked list of preferences. It's left dangling, pointing at
garbage. (Search on `XXX safe?' in wmem_remove_preference().)

If I can't figure this out, I might need to make a doubly-linked list
of preferences that are owned by each instantiation so I can yank it
there. Hrm, need to think about this a bit more...

                        *       *       *

Maybe I don't need to remember what preferences are owned by an
instantiation at all. Instead, I could just re-process the RHS using
the instantiation that's about to get nuked.

Okay, I think I see the problem with that idea: the instantiation
doesn't remember any identifiers that get generated for unbound
variables. So we won't know how to remove those. Grr.


Sunday, January 21, 2001

I've got some weird corruption crasher going on, Linux only, after
loading `p1.soar' and elaborating a couple of times. It looks like a
preference is holding a dangling pointer in its
`next_in_instantiation' field.

In the spirit of forward flailing, I cobbled together simple negative
conditions in the RETE net; enough to get `p2.soar' nominally
`working'. (It's one frigging production, so it's not like I have a
clue whether this stuff'll fly.) Need to debug in earnest at some
point.

I should create a `preferences' command so that I can add `found-line'
preference to the state to debug the negative condition foo.


Tuesday, January 16, 2001

Got a crude stab at getting the operator decision logic implemented. I
think I might be running into another RETE bug; can't seem to the the
`reconsider' production to fire in `p1.soar'.

                          *       *       *

Okay, so I think I figured out what was wrong: had an off-by-one in
the rete code and was notifying the rete network with the wrong wme
:-/. Now I keep selected `reconsider*wait* over and over again;
however, I'm a bit worried because I don't get new identifiers. Not
that I *expected* to, but I think that `real' Soar might regenerate
identifiers for each new operator that gets selected. Is that
necessary?


Monday, January 15, 2001

So the problem wasn't with propogating wmes into new rules: I was
incorrectly getting some conditions marked randomly as `acceptable'
tests (because I didn't initialize `acceptable' properly in the
`id_test' reduction). Anyway, got past that, but now it seems I'm
getting some token corruption while adding the wme to working memory.


Sunday, January 14, 2001

Seems like it might be a good thing to do away with `productions' in
the runtime. I don't see a real good reason that we need to remember
them.

It looks like the code that's supposed to propogate existing WMEs into
new rules is broken. Gotta look at that.


Monday, January 8, 2001

Need to finish up the semantic actions for rule right-hand
sides. Should simplify so that reductions can uniformly refer to $0 to
add actions.


Wednesday, January 3, 2001

I made WMEs just refer back to the slot they're in to pick up the `id'
and `attr' fields. Can we do the same with preferences?


Friday, December 29, 2000

Hacked up basic symbol table stuff, but will need to expand later to
cough up identifiers by `gc'-ing through live WMEs to find unused
ids. Left off while debugging preferences.


Thursday, December 28, 2000

Fixed the action struct's depth foo as described below.


Tuesday, December 26, 2000

Kludged my way through getting preference memory started. Need to fix
create_instantiation() to do bonafide `gensym'-ing. Maybe it's time to
make a real symbol table?

Also, I hard-coded the initialization of the action struct's `depth'
and `field' values when the rhs_value is a variable binding. That'll
need to move into the rule compilation. Maybe we can initialize with a
variable symbol, and then resolve when making the p-node?


Monday, December 25, 2000

Debugged a single-condition production. Now I'm bombing in a
production with two positive conditions. Gotta fix that.


Tuesday, December 19, 2000

I've got the basic stuff for alpha nodes, memory nodes, and positive
join nodes hooked up. I'm starting to go through debugging
|rete_add_wme()|, and am bombing out in the right-addition routine
because I'm not getting a binding for the `S1' stuff. Need to debug
that.


Tuesday, December 5, 2000

There's also starting to be a bit of redundant code, so a bit of
refactoring will probably be in order shortly.


Monday, December 4, 2000

The rete propogation stuff is buggy right now. The problem is that:

1) I'm just naively letting stuff meander down the net. This'll cause
instantiation nodes to get tickled more than once. I think I need to
make the tests more restrictive by default; esp. simple_test() should
return zero at the end?

2) (Maybe the same as 1, above) I need to be able to go out and check
working memory for values. When I see a WME in simple_test() that
doesn't have the same attribute as the node I'm looking at, I should
go out to working memory and see if there is any element that'll
satisfy my conditions, and only then propogate the stuff onward...

