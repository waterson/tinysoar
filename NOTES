-*- Mode: Text -*

Beta Network

- Memory node (also `mem node' or `m node'). A `beta memory'
  node. Can be hashed or unhashed. Creates and stores |token| objects?

- Positive node (also `pos node' and `p node'). Can be hashed or unhashed.

- MP node. Can be hashed or unhashed. Combined `memory node' and
  `positive node' to save space? From the `node_[left|right]_addition'
  routines, it appears that this is the case...

- Negative node. Can be hashed or unhashed.

- Dummy top node. Parents all of the other beta nodes in the network.

- Dummy matches node.

- CN (conjunctive negative) node, and CN-partner node.

- P (production?) node. 

hashed versus unhashed beta memory nodes? Why are some hashed and
others aren't? All that appears to be different is the computation of
the hash value that's used to find appropriate tokens...

A |token| appears to be the partially instantiated rule. There is a
`dummy top token' that is assigned to the `dummy top node' which is
the eventual ancestor of every beta node. Each token is hashed into
the `left hashtable'.

What is the difference between `left' and `right' memory?

- the `left addition' routines all take a |rete_node|, a |token|, and
  a |wme|; the `right addition' routines take a |rete_node| and a |wme|,
  but not a |token|. What's going on here?

- After adding a new |wme| to alpha memory, we call the `right node
  addition routine' for each beta node that hangs off of the alpha
  memory.

- The beta node addition routines only call the `left node addition
  routines'.

- Interestingly, there is no `right node addition routine' for a
  memory node; however, there *is* a `right node addition routine' for
  an MP node. Here's how they break down...

  DUMMY_TOP_BNODE           no addition routines
  DUMMY_MATCHES_BNODE       left addition routine only
  [UNHASHED_]MEMORY_BNODE   left only
  [UNHASHED_]POSITIVE_BNODE right only
  [UNHASHED_]MP_BNODE       left & right
  [UNHASHED_]NEGATIVE_BNODE left & right
  CN_[PARTNER_]BNODE        left only
  P_BNODE                   left only

- So, is the alpha network `right memory' and the beta network `left
  memory'?

What is `unlinking'?

Starting to understand how a production is converted into beta nodes a
bit better. Specifically, how `variable bindings' work. So we parse
the list of conditions, and as we do so, we both create beta nodes and
build up a list of `variable bindings'. A `variable binding' is simply
a `field' (the id, attr, or value) and a `depth' in the beta network.

When we make a new condition node, we `sparsely' beind variables
before creating the rete tests (so that, at worst, if a variable is
not yet bound, it the test will be `scoped' to the current beta
node). Then, after the condition node has been created, we formally
push the variables onto the stack (so that subsequent users of these
variables can find them).

After we're done parsing the list of conditions, we remove all of the
variable bindings. (Which, BTW, are stored in the `symbol table',
making this part of the code non-reentrant.)

---

For a condition like `(state <s>)', Soar is creating a conjunctive
condition whose first part is a `goal id' test, and whose second part
is an `equality test'. It looks like how this works then is that the
`goal id' part of the test checks the WME's `id' field to see if the
identifier is actually a goal, and the second part of the test binds
the goal to a variable. Tricky!

---

Hack for computing code size...

h8300-hitachi-hms-objdump --section-headers *.o |\
 grep .text |\
 awk '{ print $3; }' |\
 perl -e 'while (<>) { $sum += hex($_); } print "$sum\n";'

---

I was thinking that it might be possible to shrink WMEs and generally
save space by having a WME just maintain its `value', and get its `id'
and `attr' from its slot...

  struct wme {
    struct slot* slot;
    symbol_t     value;
    ...
  };

You could then enumerate all of the WMEs in the system by enumerating
the agent's `slots' hashtable. The only problem with this scheme are
WMEs that are created `outside' the RETE network; e.g., by somebody
doing brain surgery on the agent.

---

CHUNKING

  1. Collect all ``result'' preferences created by an instantiation,
     that is, preferences for superstates,
     |get_results_for_instantiation()| in chunk.c does this.

  2. For each preference, call |backtrace_through_instantiation()|
     with the instantiation that created the preference. (Which is a
     bit weird, because shouldn't all the preferences have been
     created by the same instantiation?)

  3. Repeatedly |trace_locals()|, |trace_grounded_potentials()|, and
     |trace_ungrounded_potentials()| until there are no more (?)
     ungrounded potentials.

  4. Build the chunk conditions.

  backtrace_through_instantiation(inst, grounds_level, trace_cond, indent)

    1. Bail if we've already backtraced this |inst|; otherwise, note
       that we've backtraced it.

    2. Mark the transitive closure of each higher goal that was tested
       in the ID field of a top-level positive condition.

Hmm. Interesting. We associate a level in the goal stack with each
identifier: this is important for chunking. Presumably identifiers
``created'' in a subgoal get ``promoted'' to the goal-level to which
they were returned.

Okay, so |preference| is going to have to change. Instead of
maintaining a doubly-linked list of the preferences in the current
instantiation, it's going to need a back-pointer to the instantiation
that created it. From the instantiation, we can get the token, and
from the token, I think we can walk back up through the identifiers
that we tested. Hrm, but how to get from _those_ identifiers to the
preference that created it? (Do we need to?)

---

I _could_ incorporate the goal-level into the identifier's symbol
itself: the highest two bits would continue to discriminate the symbol
type, some number of the remaining high bits would encode the
goal-level, and the low bits would be the identifier. Of course, with
a 16-bit word, we start to run into some scarcity problems. For
example, 2/4/10 leaves us 16 goal levels with 1024 identifiers (which
is probably not unreasonable). Promotion would simply occur at
assignment time.

That said, the old Soar code has a bunch of magic for finding
``clones'' (i.e., same identifier, different goal-level). I'm not sure
how important that is yet.

---

Since wme has a back-pointer to its slot, I think that we should be
able to do everything we need to do in the RETE network.

  . For each preference |pref| that got created as a result:

    . Use the |pref->instantiation| back-pointer to determine the
      instantiation |inst| that created the preference

    . Start with token |tok| set to the |inst->token|; that is, the
      token that is the tail of the instantiated match. walk up |tok|
      via the |tok->parent| links. For each token |tok| along the
      chain:

      . The WME |wme| that instantiated the token is accessible via
        |tok->wme|. The test is accessable via |tok->node|. The
        preferences that created |wme| are accessible via
        |wme->slot->preferences|. Recurse here!


---

Trying to understand the backtracing algorithm...

  var grounds_level;

  procedure backtrace_through_instantiation(inst)
  begin
    |tc| = {}; /* the transitive closure of ... XXXwhat? */
    do
      foreach positive condition |c| in |inst|
      begin
        if |c.id| is in |tc| then
          /* the ID is in the transitive closure, so add the value */
          |tc| = |tc| U |c.value|
        else if |c.id| is a goal and |c.wme.id.level <= grounds_level| then
          /* id is a higher goal that was tested, so add the value */
          |tc| = |tc| U |c.value|
        endif
      end
    until |tc| is reaches a fix point.

    foreach condition |c| in |inst|
    begin
      if |c| is a positive condition then
        if |c.id| in |tc| then
          |grounds| = |grounds| U |c|;
        else if |c.wme.id.level <= grounds_level| then
          |potentials| = |potentials| U |c|;
        else
          |locals| = |locals| U |c|;
        endif
      else
        /* negative condi's are either grounds or potentials */
        |negated| = |negated| U make_chunk_cond_for(|c|);
      endif
    end

    /* add new nots to the not-set */
    if |inst.nots| then
      |instantiations_with_nots| = |instantiations_with_nots| U |inst|
    endif
  end.

  procedure trace_locals()
  begin
    foreach condition |c| in |locals| do
      |locals| = |locals| - |c|;

      /* did we test a preference at this level that's a clone of some
         higher-level preference? */
      |bt_pref| = find_clone_for_level(|c.wme.preference|, |grounds_level| + 1);
      if |bt_pref| then
        /* backtrace through the instantiation that created the
           preference in our current match-goal level */
        backtrace_through_instantiation(|br_pref.instantiation|);

        /* XXX check if any prohibit preferences */
      else if |c.id| is a goal and |c.attr| == "quiescence" and |c.value| == "t" then
        |variablize_this_chunk| = false;
      else
        |potentials| = |potentials| U |c|;
      endif
    end
  end.

  procedure trace_grounded_potentials()
  begin
    |tc| = {};
    foreach positive condition |c| in |grounds| do
      |tc| = |tc| U |c.id| U |c.value|;
    end

    do
      foreach condition |c| in |potentials| do
        if |c.id| in |tc| then /* XXX NCC */
          |grounds| = |grounds| U |c|;
        endif
      end
    until |grounds| reaches a fix point.
  end.

  procedure trace_ungrounded_potentials()
  begin
    /* pick out positive potentials that we can backtrace through */
    |pots_to_bt| = {};

    foreach condition |c| in |potentials| do
      |bt_pref| = find_clone_for_level(|c.wme.preference|, |grounds_level| + 1);
      if |bt_pref| then
        |potentials| = |potentials| - |c|
        |pots_to_bt| = |pots_to_bt| U |c|
      endif
    end

    foreach condition |c| in |pots_to_bt| do
      |bt_pref| = find_clone_for_level(|c.wme.preference|, |grounds_level| + 1);

      backtrace_through_instantiation(|bt_pref.instantiation|);

      /* XXX check if any prohibits preferences */
    end
  end.

  procedure chunk(inst)
  begin
    /* inst.match_goal_level = lowest goal tested; i.e., the
       goal-level at which this instantiation ``fired''? */
    |grounds_level| = |inst.match_goal_level| - 1;

    |results| = get_results_of(inst);
    foreach |pref| in |results| do
      /* XXX isn't pref.instantiation always == inst?
      backtrace_through_instantiation(|pref.instantiation|);
    done

    do
      trace_locals();
      trace_grounded_potentials();
      trace_ungrouneded_potentials();
    until (|potentials| == {})

    foreach condition |c| in |grounds| do
      /* add |c| to new chunk's conditions */
    end

    /* XXX deal with nots */

    /* variablize the chunk */

    /* add goal or impasse tests */
  end.

I think that one thing that'll be hard to do in the raw RETE net will
be to figure out how to string together matching |id| and |value|
tests, as we need to do in |backtrace_through_instantiation()|.
